# GitHub Copilot / Agent Instructions for this repo ✅

## 目标（Why）
本仓库是一个小型的 Go 工具，用于从文本文件中解析 IP 地址（支持单个 IP、IP 段和 CIDR），输出解析后的 IP 列表。主要实现集中在 `main.go` 中的解析函数。

## 关键文件 🧭
- `main.go` — 解析逻辑的全部实现（`ParseIPFile`, `parseCIDR`, `parseIPRange`, `compareIP`等）。
- `iplist.txt` — 输入示例：支持空行、以 `#` 或 `//` 开头的注释、CIDR (`192.168.1.0/30`)、IP 段 (`192.168.1.2-192.168.1.5`) 与单个 IP。
- `go.mod` — 模块文件（在仓库根目录）。

## 快速入门：构建 & 检查 🔧
- 构建：`go build`（在仓库根目录运行）
- 格式化：`gofmt -w .` 或 `go fmt ./...`
- 静态检查：`go vet ./...`
- 测试（当前无测试）：`go test ./...`（请为解析函数添加表驱动测试）

## 项目约定与可发现模式 📌
- 源代码注释与错误消息均为中文，保持一致性：新增代码、注释与错误信息请使用中文。
- 解析输入的容错策略：空行与 `#`、`//` 注释被忽略；非法行会导致 `ParseIPFile` 返回错误并指出行号。
- 仅支持 IPv4：`parseCIDR` 和 `parseIPRange` 都在内部调用 `.To4()` 并在非 IPv4 场景返回错误。
- 对大范围的安全保护：`parseCIDR` 在当 IP 数量超过 1,000,000 时会返回错误以避免 OOM/长时间运行。

## 已发现的重要问题（请优先关注） ⚠️
- `parseCIDR` 存在逻辑错误：循环中用于自增 IP 的 `incIP` 被传入了 `ip.To4()` 的副本 (`ipBytes`)，但循环条件与输出使用的是 `ip`，因此 IP 值可能不会被正确自增，从而导致无限循环或重复输出。请在修复前为该函数添加单元测试覆盖（例如：`192.168.1.0/30` 应当产生 4 个地址）。

建议的测试与验证步骤：
1. 新建 `parser_test.go`（或 `main_test.go`）并用表驱动测试覆盖：
   - 单 IP（`192.168.1.1`）
   - IP 段（`192.168.1.1-192.168.1.3`）
   - CIDR（`192.168.1.0/30` 期望 4 个地址）
   - 注释/空行跳过行为
   - 非 IPv4 输入返回错误
2. 运行 `go test ./...` 并确保修复不会破坏其他行为。

## 最近变更记录
- 添加 `parser_test.go`，覆盖 CIDR、IP 段、单 IP、注释/空行和非 IPv4 场景的测试。
- 修复 `parseCIDR` 中的 IP 迭代逻辑：使用独立的可变 `current` 字节数组来安全迭代 CIDR 内的 IP，避免修改原始 `ip` 导致的副本/不正确自增问题。
- 改进 `ping` 探测逻辑：在 `pingWithRetry` 中采集命令输出进行更鲁棒的成功判定（跨平台的 `bytes from`、`ttl`、成功接收包计数、`0% packet loss` 等判据），修复 `context` 使用（不在循环中 defer cancel 导致资源累积），并为输出解析添加 `ping_output_test.go` 单元测试。
- 更新 `pingWithRetry` 决策策略：最多尝试 5 次，若达到 3 次成功则提前判定为存活并停止；如出现连续 3 次失败则提前判定为失败并停止。添加 `ping_logic_test.go` 覆盖判定规则的边界情况。
- 新增 `PingConfig` 配置结构并提供 `PingIPsWithConfig`：可通过 `MaxAttempts`、`SuccessNeed`、`ConsecutiveFailStop`、`Timeout` 和 `AttemptInterval` 调整探测策略；保留 `PingIPs` 作为使用默认配置的便捷函数。添加 `ping_config_test.go` 覆盖配置传递行为。

## 小提示 / PR 指南 💡
- 小而明确的提交：解析器更改应伴随相应单元测试。
- 保持错误信息和注释为中文以便与现有风格一致。
- 如果引入外部 linter（如 `golangci-lint`），请在 PR 中说明并添加配置文件。

## 当你是 AI 代理时的工作准则 🤖
- 只对可观察到的代码和文件作出修改；不要假设其它工具或 CI 配置存在。
- 先添加测试再修改实现（测试驱动修复优先）。
- 当发现潜在风险（如无限循环或大 O(n) 内存分配）时，在 PR 描述中明确指出并写入测试能复现的问题。

---

如果你希望，我可以：
- 提交一个基于表驱动的 `parser_test.go` 测试套件（覆盖上述场景），或
- 提交一个修复 `parseCIDR` 的补丁并附带测试。

请告诉我你想要我先做哪一项（添加测试 / 修复并添加测试 / 仅创建说明）。谢谢！